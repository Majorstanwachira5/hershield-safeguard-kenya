import { Response, NextFunction } from 'express';
import { AuthRequest } from '../middleware/auth';
import { asyncHandler, createError } from '../middleware/errorHandler';
import { logger } from '../utils/logger';
import { AIService } from '../services/aiService';
import { ThreatReport } from '../models/ThreatReport';
import { User } from '../models/User';

const aiService = new AIService();

// @desc    Analyze message for potential threats
// @route   POST /api/v1/ai/analyze-message
// @access  Private
export const analyzeMessage = asyncHandler(async (req: AuthRequest, res: Response, next: NextFunction) => {
  const { message, sender, context = 'unknown' } = req.body;

  try {
    // Analyze the message using AI service
    const analysis = await aiService.analyzeMessage(message, context);

    // Log the analysis for monitoring
    logger.info(`Message analyzed for user ${req.user.email}: threat level ${analysis.threatLevel}`);

    // If high threat detected, create a report
    if (analysis.threatLevel >= 8) {
      await ThreatReport.create({
        userId: req.user.id,
        content: message,
        sender,
        context,
        threatType: analysis.detectedThreats,
        riskLevel: analysis.threatLevel >= 9 ? 'high' : 'medium',
        aiAnalysis: analysis,
        status: 'pending_review',
        autoGenerated: true
      });

      // Update user's safety score if needed
      const user = await User.findById(req.user.id);
      if (user && user.safetyScore > 70) {
        user.safetyScore = Math.max(user.safetyScore - 5, 0);
        await user.save({ validateBeforeSave: false });
      }
    }

    res.status(200).json({
      success: true,
      data: {
        analysis,
        actionRequired: analysis.threatLevel >= 6,
        recommendations: analysis.recommendations
      }
    });
  } catch (error) {
    logger.error('AI analysis error:', error);
    return next(createError('Failed to analyze message', 500));
  }
});

// @desc    Detect general threats in content
// @route   POST /api/v1/ai/detect-threat
// @access  Private
export const detectThreat = asyncHandler(async (req: AuthRequest, res: Response, next: NextFunction) => {
  const { content } = req.body;

  try {
    const threatAnalysis = await aiService.detectThreats(content);

    res.status(200).json({
      success: true,
      data: {
        threats: threatAnalysis.threats,
        riskLevel: threatAnalysis.riskLevel,
        confidence: threatAnalysis.confidence,
        suggestedActions: threatAnalysis.suggestedActions
      }
    });
  } catch (error) {
    logger.error('Threat detection error:', error);
    return next(createError('Failed to detect threats', 500));
  }
});

// @desc    Moderate content for safety
// @route   POST /api/v1/ai/moderate-content
// @access  Private
export const moderateContent = asyncHandler(async (req: AuthRequest, res: Response, next: NextFunction) => {
  const { content } = req.body;

  try {
    const moderation = await aiService.moderateContent(content);

    res.status(200).json({
      success: true,
      data: {
        isAppropriate: moderation.isAppropriate,
        flags: moderation.flags,
        categories: moderation.categories,
        severity: moderation.severity,
        suggestedAction: moderation.suggestedAction
      }
    });
  } catch (error) {
    logger.error('Content moderation error:', error);
    return next(createError('Failed to moderate content', 500));
  }
});

// @desc    Check for harassment patterns
// @route   POST /api/v1/ai/check-harassment
// @access  Private
export const checkForHarassment = asyncHandler(async (req: AuthRequest, res: Response, next: NextFunction) => {
  const { content } = req.body;

  try {
    const harassmentAnalysis = await aiService.analyzeForHarassment(content);

    res.status(200).json({
      success: true,
      data: {
        isHarassment: harassmentAnalysis.isHarassment,
        type: harassmentAnalysis.type,
        severity: harassmentAnalysis.severity,
        patterns: harassmentAnalysis.patterns,
        recommendations: harassmentAnalysis.recommendations
      }
    });
  } catch (error) {
    logger.error('Harassment analysis error:', error);
    return next(createError('Failed to analyze harassment', 500));
  }
});

// @desc    Analyze sentiment of content
// @route   POST /api/v1/ai/analyze-sentiment
// @access  Private
export const analyzeSentiment = asyncHandler(async (req: AuthRequest, res: Response, next: NextFunction) => {
  const { content } = req.body;

  try {
    const sentiment = await aiService.analyzeSentiment(content);

    res.status(200).json({
      success: true,
      data: {
        sentiment: sentiment.sentiment,
        confidence: sentiment.confidence,
        emotions: sentiment.emotions,
        intensity: sentiment.intensity
      }
    });
  } catch (error) {
    logger.error('Sentiment analysis error:', error);
    return next(createError('Failed to analyze sentiment', 500));
  }
});

// @desc    Generate personalized safety advice
// @route   POST /api/v1/ai/safety-advice
// @access  Private
export const generateSafetyAdvice = asyncHandler(async (req: AuthRequest, res: Response, next: NextFunction) => {
  const { situation, category = 'general' } = req.body;

  try {
    // Get user's profile for personalized advice
    const user = await User.findById(req.user.id);
    if (!user) {
      return next(createError('User not found', 404));
    }

    const advice = await aiService.generateSafetyAdvice(situation, category, {
      location: user.location,
      safetySettings: user.safetySettings,
      previousReports: user.reportsMade
    });

    res.status(200).json({
      success: true,
      data: {
        advice: advice.recommendations,
        immediateActions: advice.immediateActions,
        preventiveMeasures: advice.preventiveMeasures,
        resources: advice.resources,
        urgencyLevel: advice.urgencyLevel
      }
    });
  } catch (error) {
    logger.error('Safety advice generation error:', error);
    return next(createError('Failed to generate safety advice', 500));
  }
});

// @desc    Assess risk level based on multiple factors
// @route   POST /api/v1/ai/assess-risk
// @access  Private
export const assessRiskLevel = asyncHandler(async (req: AuthRequest, res: Response, next: NextFunction) => {
  const { factors, location, timeOfDay } = req.body;

  try {
    const user = await User.findById(req.user.id);
    if (!user) {
      return next(createError('User not found', 404));
    }

    const riskAssessment = await aiService.assessRisk({
      factors,
      location: location || user.location?.city,
      timeOfDay,
      userProfile: {
        safetyScore: user.safetyScore,
        previousIncidents: user.reportsReceived,
        safetySettings: user.safetySettings
      }
    });

    res.status(200).json({
      success: true,
      data: {
        riskLevel: riskAssessment.riskLevel,
        riskScore: riskAssessment.riskScore,
        primaryConcerns: riskAssessment.primaryConcerns,
        mitigationStrategies: riskAssessment.mitigationStrategies,
        recommendedActions: riskAssessment.recommendedActions,
        emergencyContactSuggestion: riskAssessment.emergencyContactSuggestion
      }
    });
  } catch (error) {
    logger.error('Risk assessment error:', error);
    return next(createError('Failed to assess risk', 500));
  }
});

// @desc    Generate emergency response plan
// @route   POST /api/v1/ai/emergency-response
// @access  Private
export const generateEmergencyResponse = asyncHandler(async (req: AuthRequest, res: Response, next: NextFunction) => {
  const { emergencyType, location, immediateHelp = false, details } = req.body;

  try {
    const user = await User.findById(req.user.id);
    if (!user) {
      return next(createError('User not found', 404));
    }

    const emergencyResponse = await aiService.generateEmergencyResponse({
      emergencyType,
      location: location || user.location?.city || 'Nairobi',
      immediateHelp,
      details,
      userContext: {
        emergencyContacts: user.emergencyContacts,
        safetySettings: user.safetySettings,
        location: user.location
      }
    });

    // Log emergency situation
    logger.warn(`Emergency response generated for user ${req.user.email}: ${emergencyType}`);

    // Create high-priority threat report
    await ThreatReport.create({
      userId: req.user.id,
      content: `Emergency situation: ${emergencyType}. ${details || ''}`,
      context: 'emergency',
      threatType: [emergencyType],
      riskLevel: 'critical',
      status: 'urgent',
      autoGenerated: true,
      location: location || user.location?.city,
      aiAnalysis: {
        emergencyType,
        immediateHelp,
        responseGenerated: true
      }
    });

    res.status(200).json({
      success: true,
      data: {
        immediateActions: emergencyResponse.immediateActions,
        emergencyContacts: emergencyResponse.emergencyContacts,
        safetyInstructions: emergencyResponse.safetyInstructions,
        localResources: emergencyResponse.localResources,
        followUpSteps: emergencyResponse.followUpSteps,
        isUrgent: emergencyResponse.isUrgent
      }
    });
  } catch (error) {
    logger.error('Emergency response generation error:', error);
    return next(createError('Failed to generate emergency response', 500));
  }
});
